<!doctype html>
<html>

<head>
        <meta name="viewport" content="width=device-width,initial-scale=1">
        <style>
                html,
                body {
                        margin: 0;
                        height: 100%;
                        background: #111;
                        color: #eee;
                        font-family: system-ui;
                }

                #wrap {
                        position: relative;
                        height: 100%;
                }

                video {
                        position: absolute;
                        inset: 0;
                        width: 100%;
                        height: 100%;
                        object-fit: contain;
                        background: #000;
                }

                canvas {
                        position: absolute;
                        background: transparent;
                        inset: 0;
                        width: 100%;
                        height: 100%;
                }


                #toolbar {
                        position: absolute;
                        top: 8px;
                        left: 8px;
                        display: flex;
                        gap: 8px;
                        background: rgba(0, 0, 0, .45);
                        padding: 8px;
                        border-radius: 10px;
                }

                input[type=color] {
                        width: 34px;
                        height: 34px;
                        border: none;
                        border-radius: 6px;
                        padding: 0;
                }

                input[type=range] {
                        width: 120px;
                }

                #roomui {
                        position: absolute;
                        top: 8px;
                        right: 8px;
                        background: rgba(0, 0, 0, .45);
                        padding: 8px;
                        border-radius: 10px;
                }

                button {
                        border: none;
                        border-radius: 8px;
                        padding: 8px 10px;
                        background: #44BEFF;
                        color: #fff;
                        cursor: pointer
                }

                button.secondary {
                        background: #444
                }
        </style>
</head>

<body>
        <div id="wrap">
                <video id="remote" autoplay playsinline></video>
                <canvas id="draw"></canvas>
                <div id="toolbar">
                        <input id="color" type="color" value="#44BEFF">
                        <input id="size" type="range" min="2" max="18" value="5">
                        <button id="clear" class="secondary">Clear</button>
                </div>
                <div id="roomui">
                        <input id="room" placeholder="room code" style="padding:8px;border-radius:8px;border:none">
                        <button id="connect">Connect</button>
                </div>
        </div>
        <script type="module">
                const scheme = location.protocol === 'https:' ? 'wss' : 'ws';
                const ws = new WebSocket(`${scheme}://${location.host}/ws`);
                ws.addEventListener('open', () => console.log('[coach] ws open'));
                ws.addEventListener('close', () => console.log('[coach] ws close'));
                ws.addEventListener('error', (e) => console.log('[coach] ws error', e));
                const { iceServers } = await(await fetch("/ice")).json();
                const pc = new RTCPeerConnection({ iceServers, iceCandidatePoolSize: 2 });
                const remote = document.getElementById('remote');
                const canvas = document.getElementById('draw');
                const ctx = canvas.getContext('2d');
                const wrap = document.getElementById('wrap');

                function clamp(v, min = 0, max = 1) {
                        return Math.max(min, Math.min(max, v));
                }

                function getContainRect(videoEl) {
                        const vw = videoEl.videoWidth || 0;
                        const vh = videoEl.videoHeight || 0;
                        const cw = wrap.clientWidth;
                        const ch = wrap.clientHeight;
                        if (!vw || !vh || !cw || !ch) return { x: 0, y: 0, w: cw, h: ch };

                        const vidAR = vw / vh;
                        const boxAR = cw / ch;

                        if (boxAR > vidAR) {
                                const h = ch;
                                const w = Math.round(h * vidAR);
                                const x = Math.round((cw - w) / 2);
                                return { x, y: 0, w, h };
                        } else {
                                const w = cw;
                                const h = Math.round(w / vidAR);
                                const y = Math.round((ch - h) / 2);
                                return { x: 0, y, w, h };
                        }
                }

                function setupCanvas() {
                        const dpr = window.devicePixelRatio || 1;
                        canvas.width = Math.floor(wrap.clientWidth * dpr);
                        canvas.height = Math.floor(wrap.clientHeight * dpr);
                        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                }
                const roomInput = document.getElementById('room');
                const connectBtn = document.getElementById('connect');
                const color = document.getElementById('color');
                const size = document.getElementById('size');

                let dataChan;
                let roomId;

                function fit() { setupCanvas(); }
                window.addEventListener('resize', fit);
                new ResizeObserver(fit).observe(wrap);
                remote.addEventListener('loadedmetadata', fit);

                async function logSelectedPair(role) {
                        const stats = await pc.getStats();
                        let pair, local, remote;
                        stats.forEach(r => { if (r.type === 'candidate-pair' && r.nominated) pair = r; });
                        if (pair) {
                                local = stats.get(pair.localCandidateId);
                                remote = stats.get(pair.remoteCandidateId);
                                console.log(`[${role}] selected pair`, {
                                        state: pair.state,
                                        localType: local?.candidateType, remoteType: remote?.candidateType
                                });
                        }
                }
                pc.addEventListener('connectionstatechange', () => {
                        if (pc.connectionState === 'connected') logSelectedPair('coach');
                });

                pc.ontrack = (ev) => {
                        remote.srcObject = ev.streams[0];
                };

                ws.onmessage = async (ev) => {
                        const { type, payload } = JSON.parse(ev.data);
                        console.log('[coach] ws msg:', type, payload);

                        if (type === 'created') return;

                        if (type === 'peer-joined') {
                                try {
                                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
                                        stream.getTracks().forEach(t => pc.addTrack(t, stream));
                                } catch (err) {
                                        console.error("Failed to get audio", err);
                                        return;
                                }

                                dataChan = pc.createDataChannel('anno');
                                dataChan.onopen = () => console.log('anno channel open (coach)');
                                const offer = await pc.createOffer();
                                await pc.setLocalDescription(offer);
                                wsSendSafe(ws, { type: 'sdp', payload: pc.localDescription, roomId });
                                return;
                        }

                        if (type === 'sdp') {
                                const desc = payload;
                                if (desc.type === 'offer') {
                                        await pc.setRemoteDescription(desc);
                                        const ans = await pc.createAnswer();
                                        await pc.setLocalDescription(ans);
                                        wsSendSafe(ws, { type: 'sdp', payload: pc.localDescription, roomId });
                                } else {
                                        await pc.setRemoteDescription(desc);
                                }
                                return;
                        }

                        if (type === 'ice') {
                                try { await pc.addIceCandidate(payload); } catch { }
                                return;
                        }
                };


                pc.onicecandidate = (e) => {
                        if (e.candidate) wsSendSafe(ws, { type: 'ice', payload: e.candidate, roomId });
                };

                function wsSendSafe(ws, msg) {
                        const data = JSON.stringify(msg);
                        if (ws.readyState === WebSocket.OPEN) {
                                ws.send(data);
                        } else {
                                ws.addEventListener('open', () => ws.send(data), { once: true });
                        }
                }

                function send(type, payload) {
                        wsSendSafe(ws, { type, payload, roomId });
                }

                connectBtn.onclick = () => {
                        roomId = roomInput.value.trim();
                        if (!roomId) return;
                        wsSendSafe(ws, { type: 'create', roomId });
                };

                // drawing
                let drawing = false; let points = [];
                canvas.addEventListener('pointerdown', e => { drawing = true; points = [toNorm(e)]; canvas.setPointerCapture(e.pointerId); });
                canvas.addEventListener('pointermove', e => {
                        if (!drawing) return;

                        const p = toNorm(e);
                        const pLast = points[points.length - 1];
                        drawLocal([pLast, p], color.value, +size.value);
                        points.push(p);
                });
                canvas.addEventListener('pointerup', () => {
                        if (!drawing) return; drawing = false;
                        if (dataChan?.readyState === 'open') {
                                dataChan.send(JSON.stringify({ kind: 'stroke', points, color: color.value, width: +size.value }));
                        }
                        points = [];
                });

                document.getElementById('clear').onclick = () => {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        if (dataChan?.readyState === 'open') dataChan.send(JSON.stringify({ kind: 'clear' }));
                };

                function toNorm(e) {
                        const wrapRect = wrap.getBoundingClientRect();
                        const rect = getContainRect(remote); // video draw box inside wrap
                        const x = (e.clientX - wrapRect.left - rect.x) / rect.w;
                        const y = (e.clientY - wrapRect.top - rect.y) / rect.h;
                        return [clamp(x), clamp(y)];
                }

                function drawLocal(pts, color = '#0f8', width = 4) {
                        if (pts.length < 2) return;
                        const rect = getContainRect(remote);
                        ctx.lineJoin = ctx.lineCap = 'round';
                        ctx.strokeStyle = color;
                        ctx.lineWidth = width;
                        ctx.beginPath();
                        pts.forEach(([nx, ny], i) => {
                                const x = rect.x + nx * rect.w;
                                const y = rect.y + ny * rect.h;
                                if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                        });
                        ctx.stroke();
                }
        </script>
</body>

</html>