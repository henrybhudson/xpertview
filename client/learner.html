<!doctype html>
<html>

<head>
        <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
        <style>
                html,
                body {
                        margin: 0;
                        height: 100%;
                        background: #000;
                }

                #wrap {
                        position: relative;
                        height: 100%;
                }

                video,
                canvas {
                        position: absolute;
                        inset: 0;
                        width: 100%;
                        height: 100%;
                        object-fit: cover;
                }

                #ui {
                        position: absolute;
                        top: 8px;
                        left: 8px;
                        color: #fff;
                        background: rgba(0, 0, 0, .35);
                        padding: 8px 10px;
                        border-radius: 10px;
                        font-family: system-ui;
                }
        </style>
</head>

<body>
        <div id="wrap">
                <video id="vid" autoplay playsinline muted></video>
                <audio id="remoteAudio" autoplay></audio>
                <canvas id="overlay"></canvas>
                <div id="ui">Room: <span id="room"></span></div>
        </div>
        <script type="module">
                const roomId = (new URLSearchParams(location.search).get('room') || prompt('Enter room code') || '').trim();
                document.getElementById('room').textContent = roomId || '(none)';
                if (!roomId) alert('You must provide a room code. Reload with ?room=yourcode');

                // 2) Connect WS explicitly to signalling server
                const scheme = location.protocol === 'https:' ? 'wss' : 'ws';
                const ws = new WebSocket(`${scheme}://${location.host}/ws`);
                ws.addEventListener('open', () => console.log('[learner] ws open'));
                ws.addEventListener('close', () => console.log('[learner] ws close'));
                ws.addEventListener('error', (e) => console.log('[learner] ws error', e));

                // 3) Safe sender so we never hit CONNECTING
                function wsSendSafe(ws, obj) {
                        const data = JSON.stringify(obj);
                        if (ws.readyState === WebSocket.OPEN) ws.send(data);
                        else ws.addEventListener('open', () => ws.send(data), { once: true });
                }

                // 4) SEND JOIN IMMEDIATELY (donâ€™t rely on onopen timing)
                console.log('[learner] sending join for room:', roomId);
                wsSendSafe(ws, { type: 'join', roomId });
                const { iceServers } = await(await fetch("/ice")).json();
                const pc = new RTCPeerConnection({ iceServers, iceCandidatePoolSize: 2 });

                async function logSelectedPair(role) {
                        const stats = await pc.getStats();
                        let pair, local, remote;
                        stats.forEach(r => { if (r.type === 'candidate-pair' && r.nominated) pair = r; });
                        if (pair) {
                                local = stats.get(pair.localCandidateId);
                                remote = stats.get(pair.remoteCandidateId);
                                console.log(`[${role}] selected pair`, {
                                        state: pair.state,
                                        localType: local?.candidateType, remoteType: remote?.candidateType
                                });
                        }
                }
                pc.addEventListener('connectionstatechange', () => {
                        if (pc.connectionState === 'connected') logSelectedPair('coach'); // 'learner' on learner.html
                });

                // Data channel for annotations (coach to learner)
                let dataChan = null;
                pc.ondatachannel = (e) => {
                        if (e.channel.label === 'anno') {
                                dataChan = e.channel;
                                dataChan.onmessage = ({ data }) => drawRemote(JSON.parse(data));
                        }
                };

                // capture camera and mic
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: true });
                const vid = document.getElementById('vid');
                vid.srcObject = stream;
                stream.getTracks().forEach(t => pc.addTrack(t, stream));

                function send(type, payload) { wsSendSafe(ws, { type, payload, roomId }); }

                ws.onmessage = async (ev) => {
                        const { type, payload } = JSON.parse(ev.data);
                        console.log('[learner] ws msg:', type, payload);

                        if (type === 'sdp') {
                                const desc = payload;
                                if (desc.type === 'offer') {
                                        await pc.setRemoteDescription(desc);
                                        const ans = await pc.createAnswer();
                                        await pc.setLocalDescription(ans);
                                        send('sdp', pc.localDescription);
                                } else {
                                        await pc.setRemoteDescription(desc);
                                }
                                return;
                        }

                        if (type === 'ice') {
                                try { await pc.addIceCandidate(payload); } catch { }
                                return;
                        }

                        // (Ignore created/joined/peer-joined on learner in this flow)
                };

                pc.onicecandidate = (e) => e.candidate && send('ice', e.candidate);

                const remoteAudioEl = document.getElementById('remoteAudio');

                pc.ontrack = (event) => {
                        if (event.track.kind === 'audio') {
                                remoteAudioEl.srcObject = event.streams[0];
                                remoteAudioEl.play().catch(e => console.error('Audio play failed', e));
                        }
                };

                // Draw the incoming annotations
                const canvas = document.getElementById('overlay');
                const ctx = canvas.getContext('2d');
                function fit() { canvas.width = vid.clientWidth * devicePixelRatio; canvas.height = vid.clientHeight * devicePixelRatio; }
                addEventListener('resize', fit); fit();

                function drawRemote(msg) {
                        if (msg.kind === 'clear') { ctx.clearRect(0, 0, canvas.width, canvas.height); return; }
                        if (msg.kind === 'stroke') {
                                const { points, color = '#00FF88', width = 4 } = msg;
                                ctx.lineJoin = ctx.lineCap = 'round';
                                ctx.strokeStyle = color;
                                ctx.lineWidth = width * devicePixelRatio;
                                ctx.beginPath();
                                points.forEach(([nx, ny], i) => {
                                        const x = nx * canvas.width, y = ny * canvas.height;
                                        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                                });
                                ctx.stroke();
                        }
                }
        </script>
</body>

</html>