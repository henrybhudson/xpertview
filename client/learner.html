<!doctype html>
<html>

<head>
        <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
        <style>
                html,
                body {
                        margin: 0;
                        height: 100%;
                        background: #000;
                }

                #wrap {
                        position: relative;
                        height: 100%;
                }

                video {
                        position: absolute;
                        inset: 0;
                        width: 100%;
                        height: 100%;
                        object-fit: contain;
                        background: #000;
                }

                canvas {
                        position: absolute;
                        background: transparent;
                        inset: 0;
                        width: 100%;
                        height: 100%;
                }

                #ui {
                        position: absolute;
                        top: 8px;
                        left: 8px;
                        color: #fff;
                        background: rgba(0, 0, 0, .35);
                        padding: 8px 10px;
                        border-radius: 10px;
                        font-family: system-ui;
                }
        </style>
</head>

<body>
        <div id="wrap">
                <video id="vid" autoplay playsinline muted></video>
                <audio id="remoteAudio" autoplay></audio>
                <canvas id="overlay"></canvas>
                <div id="ui">Room: <span id="room"></span></div>
        </div>
        <script type="module">
                const roomId = (new URLSearchParams(location.search).get('room') || prompt('Enter room code') || '').trim();
                document.getElementById('room').textContent = roomId || '(none)';
                if (!roomId) alert('You must provide a room code. Reload with ?room=yourcode');

                const scheme = location.protocol === 'https:' ? 'wss' : 'ws';
                const ws = new WebSocket(`${scheme}://${location.host}/ws`);
                ws.addEventListener('open', () => console.log('[learner] ws open'));
                ws.addEventListener('close', () => console.log('[learner] ws close'));
                ws.addEventListener('error', (e) => console.log('[learner] ws error', e));

                function wsSendSafe(ws, obj) {
                        const data = JSON.stringify(obj);
                        if (ws.readyState === WebSocket.OPEN) ws.send(data);
                        else ws.addEventListener('open', () => ws.send(data), { once: true });
                }

                console.log('[learner] sending join for room:', roomId);
                wsSendSafe(ws, { type: 'join', roomId });
                const { iceServers } = await(await fetch("/ice")).json();
                const pc = new RTCPeerConnection({ iceServers, iceCandidatePoolSize: 2 });

                async function logSelectedPair(role) {
                        const stats = await pc.getStats();
                        let pair, local, remote;
                        stats.forEach(r => { if (r.type === 'candidate-pair' && r.nominated) pair = r; });
                        if (pair) {
                                local = stats.get(pair.localCandidateId);
                                remote = stats.get(pair.remoteCandidateId);
                                console.log(`[${role}] selected pair`, {
                                        state: pair.state,
                                        localType: local?.candidateType, remoteType: remote?.candidateType
                                });
                        }
                }
                pc.addEventListener('connectionstatechange', () => {
                        if (pc.connectionState === 'connected') logSelectedPair('coach'); // 'learner' on learner.html
                });

                // Data channel for annotations (coach to learner)
                let dataChan = null;
                pc.ondatachannel = (e) => {
                        if (e.channel.label === 'anno') {
                                console.log("Annotation received")
                                dataChan = e.channel;
                                dataChan.onmessage = ({ data }) => drawRemote(JSON.parse(data));
                        }
                };

                // capture camera and mic
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: true });
                const vid = document.getElementById('vid');
                vid.srcObject = stream;
                stream.getTracks().forEach(t => pc.addTrack(t, stream));

                function send(type, payload) { wsSendSafe(ws, { type, payload, roomId }); }

                ws.onmessage = async (ev) => {
                        const { type, payload } = JSON.parse(ev.data);
                        console.log('[learner] ws msg:', type, payload);

                        if (type === 'sdp') {
                                const desc = payload;
                                if (desc.type === 'offer') {
                                        await pc.setRemoteDescription(desc);
                                        const ans = await pc.createAnswer();
                                        await pc.setLocalDescription(ans);
                                        send('sdp', pc.localDescription);
                                } else {
                                        await pc.setRemoteDescription(desc);
                                }
                                return;
                        }

                        if (type === 'ice') {
                                try { await pc.addIceCandidate(payload); } catch { }
                                return;
                        }

                };

                pc.onicecandidate = (e) => e.candidate && send('ice', e.candidate);

                const remoteAudioEl = document.getElementById('remoteAudio');

                pc.ontrack = (event) => {
                        if (event.track.kind === 'audio') {
                                remoteAudioEl.srcObject = event.streams[0];
                                remoteAudioEl.play().catch(e => console.error('Audio play failed', e));
                        }
                };

                // Draw the incoming annotations
                const canvas = document.getElementById('overlay');
                const ctx = canvas.getContext('2d');
                const wrap = document.getElementById('wrap');

                function clamp(v, min = 0, max = 1) {
                        return Math.max(min, Math.min(max, v));
                }

                function getContainRect(videoEl) {
                        const vw = videoEl.videoWidth || 0;
                        const vh = videoEl.videoHeight || 0;
                        const cw = wrap.clientWidth;
                        const ch = wrap.clientHeight;
                        if (!vw || !vh || !cw || !ch) return { x: 0, y: 0, w: cw, h: ch };

                        const vidAR = vw / vh;
                        const boxAR = cw / ch;

                        if (boxAR > vidAR) {
                                // limited by height
                                const h = ch;
                                const w = Math.round(h * vidAR);
                                const x = Math.round((cw - w) / 2);
                                return { x, y: 0, w, h };
                        } else {
                                // limited by width
                                const w = cw;
                                const h = Math.round(w / vidAR);
                                const y = Math.round((ch - h) / 2);
                                return { x: 0, y, w, h };
                        }
                }

                function setupCanvas() {
                        const dpr = window.devicePixelRatio || 1;
                        canvas.width = Math.floor(wrap.clientWidth * dpr);
                        canvas.height = Math.floor(wrap.clientHeight * dpr);
                        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                }

                function fit() { setupCanvas(); }
                window.addEventListener('resize', fit);
                new ResizeObserver(fit).observe(wrap);
                vid.addEventListener('loadedmetadata', fit);

                function drawRemote(msg) {
                        if (msg.kind === 'clear') { ctx.clearRect(0, 0, canvas.width, canvas.height); return; }
                        if (msg.kind === 'stroke') {
                                const { points, color = '#00FF88', width = 4 } = msg;
                                const rect = getContainRect(vid); // draw inside the video box
                                ctx.lineJoin = ctx.lineCap = 'round';
                                ctx.strokeStyle = color;
                                ctx.lineWidth = width;
                                ctx.beginPath();
                                points.forEach(([nx, ny], i) => {
                                        const x = rect.x + nx * rect.w;
                                        const y = rect.y + ny * rect.h;
                                        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                                });
                                ctx.stroke();
                        }
                }
        </script>
</body>

</html>